import { SetBonusCounts } from '@destinyitemmanager/dim-api-types';
import { TagValue } from 'app/inventory/dim-item-info';
import { DimItem, PluggableInventoryItemDefinition } from 'app/inventory/item-types';
import { ModMap } from 'app/loadout/mod-assignment-utils';
import { mapValues } from 'app/utils/collections';
import { chainComparator, compareBy } from 'app/utils/comparators';
import { getModTypeTagByPlugCategoryHash } from 'app/utils/item-utils';
import { releaseProxy, wrap } from 'comlink';
import { BucketHashes } from 'data/d2/generated-enums';
import { deepEqual } from 'fast-equals';
import type { ProcessInputs } from '../process-worker/process';
import { ProcessItem, ProcessItemsByBucket, ProcessResult } from '../process-worker/types';
import {
  ArmorBucketHash,
  ArmorEnergyRules,
  ArmorSet,
  AutoModDefs,
  DesiredStatRange,
  ItemGroup,
  ItemsByBucket,
  ModStatChanges,
} from '../types';
import {
  hydrateArmorSet,
  mapArmor2ModToProcessMod,
  mapAutoMods,
  mapDimItemToProcessItem,
} from './mappers';

function createWorker() {
  const instance = new Worker(
    /* webpackChunkName: "lo-worker" */ new URL('../process-worker/ProcessWorker', import.meta.url),
  );

  const worker = wrap<import('../process-worker/ProcessWorker').ProcessWorker>(instance);

  const cleanup = () => {
    worker[releaseProxy]();
    instance.terminate();
  };

  return { worker, cleanup };
}

export function runProcess({
  autoModDefs,
  filteredItems,
  setBonuses,
  lockedModMap,
  modStatChanges,
  armorEnergyRules,
  desiredStatRanges,
  anyExotic,
  autoStatMods,
  getUserItemTag,
  strictUpgrades,
  stopOnFirstSet,
  lastInput,
}: {
  autoModDefs: AutoModDefs;
  filteredItems: ItemsByBucket;
  setBonuses: SetBonusCounts;
  lockedModMap: ModMap;
  modStatChanges: ModStatChanges;
  armorEnergyRules: ArmorEnergyRules;
  desiredStatRanges: DesiredStatRange[];
  anyExotic: boolean;
  autoStatMods: boolean;
  getUserItemTag?: (item: DimItem) => TagValue | undefined;
  strictUpgrades: boolean;
  stopOnFirstSet: boolean;
  lastInput: ProcessInputs | undefined;
}):
  | {
      cleanup: () => void;
      resultPromise: Promise<
        Omit<ProcessResult, 'sets'> & { sets: ArmorSet[]; processTime: number }
      >;
      input: ProcessInputs;
    }
  | undefined {
  const processStart = performance.now();
  const { worker, cleanup: cleanupWorker } = createWorker();
  let cleanupRef: (() => void) | undefined = cleanupWorker;
  const cleanup = () => {
    cleanupRef?.();
    cleanupRef = undefined;
  };

  const { bucketSpecificMods, activityMods, generalMods } = lockedModMap;

  const lockedProcessMods = {
    generalMods: generalMods.map(mapArmor2ModToProcessMod),
    activityMods: activityMods.map(mapArmor2ModToProcessMod),
  };

  const autoModsData = mapAutoMods(autoModDefs);

  const processItems: ProcessItemsByBucket = {
    [BucketHashes.Helmet]: [],
    [BucketHashes.Gauntlets]: [],
    [BucketHashes.ChestArmor]: [],
    [BucketHashes.LegArmor]: [],
    [BucketHashes.ClassArmor]: [],
  };
  const itemsById = new Map<string, ItemGroup>();

  for (const [bucketHashStr, items] of Object.entries(filteredItems)) {
    const bucketHash = parseInt(bucketHashStr, 10) as ArmorBucketHash;
    processItems[bucketHash] = [];

    const groupedItems = mapItemsToGroups(
      items,
      desiredStatRanges,
      armorEnergyRules,
      activityMods,
      bucketSpecificMods[bucketHash] || [],
      Object.keys(setBonuses).map(Number),
      getUserItemTag,
    );

    for (const group of groupedItems) {
      processItems[bucketHash].push(group.canonicalProcessItem);
      itemsById.set(group.canonicalProcessItem.id, group);
    }
  }

  // TODO: could potentially partition the problem (split the largest item category maybe) to spread across more cores
  const input: ProcessInputs = {
    filteredItems: processItems,
    modStatTotals: mapValues(modStatChanges, (stat) => stat.value),
    lockedMods: lockedProcessMods,
    setBonuses,
    desiredStatRanges,
    anyExotic,
    autoModOptions: autoModsData,
    autoStatMods,
    strictUpgrades,
    stopOnFirstSet,
  };
  if (deepEqual(lastInput, input)) {
    // If the inputs are the same as last time, we can skip the worker and just
    // return the last result.
    return undefined;
  }

  return {
    cleanup,
    input,
    resultPromise: new Promise((resolve) => {
      worker
        .process(input)
        .then((result) => {
          const hydratedSets = result.sets.map((set) => hydrateArmorSet(set, itemsById));
          const processTime = performance.now() - processStart;
          resolve({ ...result, sets: hydratedSets, processTime });
        })
        // Cleanup the worker, we don't need it anymore.
        .finally(() => {
          cleanup();
        });
    }),
  };
}

interface MappedItem {
  dimItem: DimItem;
  processItem: ProcessItem;
}

// comparator for sorting items in groups generated by groupItems. These items will all have the same stats.
const groupComparator = (getTag?: (item: DimItem) => TagValue | undefined) =>
  chainComparator(
    // Prefer higher-energy (ideally masterworked)
    compareBy(({ dimItem }: MappedItem) => -(dimItem.energy?.energyCapacity || 0)),
    // Prefer owned items over vendor items
    compareBy(({ dimItem }: MappedItem) => Boolean(dimItem.vendor)),
    // Prefer favorited items
    compareBy(({ dimItem }: MappedItem) => getTag?.(dimItem) !== 'favorite'),
    // Prefer items with higher power
    compareBy(({ dimItem }: MappedItem) => -dimItem.power),
    // Prefer items that are equipped
    compareBy(({ dimItem }: MappedItem) => (dimItem.equipped ? 0 : 1)),
  );

/**
 * To reduce the number of items sent to the web worker we group items by a number of varying
 * parameters, depending on what mods and armour upgrades are selected. This is purely an optimization
 * and most of the time only has an effect for class items, but this can be a significant improvement
 * when we only have to check 1-4 class items instead of 12.
 *
 * After items have been grouped we only send a single item (the first one) as a representative of
 * said group. All other grouped items will be available by the swap icon in the UI.
 *
 * An important property of this grouping is that all items within a single group must be interchangeable
 * for any possible assignment of mods or other LO .
 *
 * Creating a group for every item is trivially correct but inefficient. Erroneously forgetting to include a bit
 * of information in the grouping key that is relevant to the web worker results in the worker failing to discover
 * certain sets, or set rendering suddenly failing in unexpected ways when it prefers an alternative due to an existing
 * loadout, so everything in ProcessItem that affects the operation of the worker
 * must be accounted for in this function.
 *
 * It can group by any number of the following concepts depending on locked mods and armor upgrades,
 * - Stat distribution
 * - Masterwork status
 * - Exoticness (every exotic must be distinguished from other exotics and all legendaries)
 * - Energy capacity
 * - Set bonus
 * - If there are mods with tags (activity/combat style) it will create groups split by compatible tags
 */
function mapItemsToGroups(
  items: readonly DimItem[],
  resolvedStatConstraints: DesiredStatRange[],
  armorEnergyRules: ArmorEnergyRules,
  activityMods: PluggableInventoryItemDefinition[],
  modsForSlot: PluggableInventoryItemDefinition[],
  setBonusHashes: number[],
  getUserItemTag?: (item: DimItem) => TagValue | undefined,
): ItemGroup[] {
  // Figure out all the interesting mod slots required by mods.
  // This includes combat mod tags because blue-quality items don't have them
  // and there may be legacy items that can slot CWL/Warmind Cell mods but not
  // Elemental Well mods?
  const requiredModTags = new Set<string>();
  for (const mod of activityMods) {
    const modTag = getModTypeTagByPlugCategoryHash(mod.plug.plugCategoryHash);
    if (modTag) {
      requiredModTags.add(modTag);
    }
  }
  const requiredModTagsArray = Array.from(requiredModTags).sort();

  // First, map the DimItems to ProcessItems so that we can consider all things relevant to Loadout Optimizer.
  const mappedItems: MappedItem[] = items.map((dimItem) => ({
    dimItem,
    processItem: mapDimItemToProcessItem({ dimItem, armorEnergyRules, modsForSlot }),
  }));

  // Build groups of "interchangeable" items
  const groupKey = ({ dimItem, processItem }: MappedItem) => {
    // Item stats are important for the stat results of a full set
    const statValues = resolvedStatConstraints.map((c) => processItem.stats[c.statHash]);
    // Energy capacity affects mod assignment
    const energyCapacity = processItem.remainingEnergyCapacity;
    // Supported mod tags affect mod assignment
    const relevantModSeasons = requiredModTagsArray.filter((tag) =>
      processItem.compatibleModSeasons?.includes(tag),
    );
    const itemSetBonusHash = dimItem.setBonus?.hash ?? 0;
    // Only group by set bonus if set bonuses are being filtered
    const setBonusHash = setBonusHashes.includes(itemSetBonusHash) ? itemSetBonusHash : 0;

    return `${dimItem.isExotic ? `${dimItem.hash}-` : 'legendary-'}${statValues.toString()}-${energyCapacity}-${setBonusHash}-${[
      relevantModSeasons,
    ].toString()}`;
  };

  // Final grouping by everything relevant
  const groups: ItemGroup[] = [];

  // Go through each grouping-by-energy-type and build groups by their properties.
  const groupedByEverything = Map.groupBy(mappedItems, groupKey);
  for (const group of groupedByEverything.values()) {
    group.sort(groupComparator(getUserItemTag));
    groups.push({
      canonicalProcessItem: group[0].processItem,
      items: group.map(({ dimItem }) => dimItem),
    });
  }

  return groups;
}
